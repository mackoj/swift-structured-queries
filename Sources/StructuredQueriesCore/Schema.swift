//import IssueReporting

// TODO: Rename to Schema
//       Nested type generated by macro also called Schema
//       Rename allColumns to columns
public protocol Schema<Value>: QueryExpression where Value: Table {
  var allColumns: [any ColumnExpression<Value>] { get }
}

extension Schema {
  public var queryString: String { allColumns.map(\.queryString).joined(separator: ", ") }
  public var queryBindings: [QueryBinding] { [] }

  // TODO: Should we keep this?
  //       If so, make more efficient with OrderedDictionary and perhaps get rid of force unwrap.
  public func column<Member>(for keyPath: KeyPath<Value, Member>) -> Column<Value, Member>? {
    for column in allColumns {
      if column.keyPath == keyPath {
        return (column as! Column<Value, Member>)
      }
    }
    return nil
  }
}

#if canImport(Foundation)
  import Foundation
  extension Schema {
    // TODO: Make efficient with orded dictionary
    public func sort(
      by keyPathComparator: KeyPathComparator<Value>
    ) -> some QueryExpression<Bool> {
      for column in allColumns {
        if column.keyPath == keyPathComparator.keyPath {
          return _KeyPathComparatorExpression(columnAndOrders: [(column, keyPathComparator.order)])
        }
      }
//      reportIssue(
//        """
//        Could not find column for key path '\(keyPathComparator.keyPath)'. This is only supported \
//        for  key paths of stored properties.
//        """
//      )
      fatalError(
        """
        Could not find column for key path '\(keyPathComparator.keyPath)'. This is only supported \
        for  key paths of stored properties.
        """
      )
    }

    public func sort(
      by keyPathComparators: [KeyPathComparator<Value>]
    ) -> some QueryExpression<Bool> {
      let columnAndOrders = keyPathComparators.compactMap { keyPathComparator in
        for column in allColumns {
          if column.keyPath == keyPathComparator.keyPath {
            return (column, keyPathComparator.order)
          }
        }
//        reportIssue(
//          """
//          Could not find column for key path '\(keyPathComparator.keyPath)'. This is only supported \
//          for  key paths of stored properties.
//          """
//        )
        fatalError(
          """
          Could not find column for key path '\(keyPathComparator.keyPath)'. This is only \
          supported for  key paths of stored properties.
          """
        )
      }
      return _KeyPathComparatorExpression(columnAndOrders: columnAndOrders)
    }
  }

  private struct _KeyPathComparatorExpression<Table>: QueryExpression {
    typealias Value = Bool
    let columnAndOrders: [(any ColumnExpression<Table>, SortOrder)]

    var queryString: String {
      var query = ""
      for (index, (column, order)) in columnAndOrders.enumerated() {
        query += """
          \(column.queryString) \
          \(order == .forward ? "ASC" : "DESC")\
          \(index < columnAndOrders.count - 1 ? ", " : "")
          """
      }
      return query
    }

    var queryBindings: [QueryBinding] { [] }
  }
#endif

// db.addColumn(SyncUp.schema.isActive.name

import SwiftData

@available(macOS 14, *)
@Model
class SyncUp {
  var id: Int
  var name: String
  var isActive: Bool
  init(id: Int, name: String, isActive: Bool) {
    self.id = id
    self.name = name
    self.isActive = isActive
  }
}
