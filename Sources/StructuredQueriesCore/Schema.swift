//import IssueReporting

// TODO: Rename to Schema
//       Nested type generated by macro also called Schema
//       Rename allColumns to columns
public protocol Schema<QueryOutput>: QueryExpression {
  var allColumns: [AnyColumnExpression<QueryOutput>] { get }
}

extension Schema {
  public var queryFragment: QueryFragment {
    allColumns.map(\.queryFragment).joined(separator: ", ")
  }

  // TODO: Should we keep this?
  //       If so, make more efficient with OrderedDictionary and perhaps get rid of force unwrap.
  public func column<Member>(for keyPath: KeyPath<QueryOutput, Member>) -> Column<QueryOutput, Member>? {
    for column in allColumns {
      if column.keyPath == keyPath {
        return (column.base as! Column<QueryOutput, Member>)
      }
    }
    return nil
  }
}

#if canImport(Foundation)
  import Foundation
  extension Schema {
    // TODO: Make efficient with orded dictionary
    @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
    public func sort(
      by keyPathComparator: KeyPathComparator<QueryOutput>
    ) -> some QueryExpression<Bool> {
      for column in allColumns {
        if column.keyPath == keyPathComparator.keyPath {
          return _KeyPathComparatorExpression(columnsAndOrders: [(column, keyPathComparator.order)])
        }
      }
//      reportIssue(
//        """
//        Could not find column for key path '\(keyPathComparator.keyPath)'. This is only supported \
//        for  key paths of stored properties.
//        """
//      )
      fatalError(
        """
        Could not find column for key path '\(keyPathComparator.keyPath)'. This is only supported \
        for  key paths of stored properties.
        """
      )
    }

    @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
    public func sort(
      by keyPathComparators: [KeyPathComparator<QueryOutput>]
    ) -> some QueryExpression<Bool> {
      let columnsAndOrders = keyPathComparators.compactMap { keyPathComparator in
        for column in allColumns {
          if column.keyPath == keyPathComparator.keyPath {
            return (column, keyPathComparator.order)
          }
        }
//        reportIssue(
//          """
//          Could not find column for key path '\(keyPathComparator.keyPath)'. This is only supported \
//          for  key paths of stored properties.
//          """
//        )
        fatalError(
          """
          Could not find column for key path '\(keyPathComparator.keyPath)'. This is only \
          supported for  key paths of stored properties.
          """
        )
      }
      return _KeyPathComparatorExpression(columnsAndOrders: columnsAndOrders)
    }
  }

  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  private struct _KeyPathComparatorExpression<Table>: QueryExpression {
    typealias QueryOutput = Bool
    let columnsAndOrders: [(AnyColumnExpression<Table>, SortOrder)]

    var queryFragment: QueryFragment {
      columnsAndOrders
        .map { "\(bind: $0) \(raw: $1 == .forward ? "ASC" : "DESC")" }
        .joined(separator: ", ")
    }
  }
#endif
